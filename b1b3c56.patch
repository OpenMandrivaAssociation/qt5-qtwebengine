commit b1b3c56422b757b1da99ad6a416316113b7c53d5
Author: Szabolcs David <davidsz@inf.u-szeged.hu>
Date:   Tue May 26 19:02:09 2020 +0200

    [Backport] Support Unicode non-characters in JSON{Parser,Writer}
    
    Per the JSON specification base::JSONParser aims to follow [1]
    (as well as JSON specifications that supersede it, such as [2]),
    JSON can encode Unicode non-characters. This patch adds support
    for such characters to base::JSONParser so that they can safely
    be transmitted via the Chrome DevTools Protocol. Thus, this patch
    removes the need for workarounds like [3] that were only needed
    due to lack of support.
    
    For symmetry, support for non-characters is added to
    base::JSONWriter as well.
    
    Note that although base::JSONParser and base::JSONWriter now
    support Unicode non-characters, invalid code points (i.e. lone
    surrogates) remain unsupported.
    
    Note that this change impacts JsonSanitizer as well: previously, if
    its input contains a non-character, JsonSanitizer would produce an
    error. Now, JsonSanitizer successfully generates sanitized JSON in
    this case, and as always, this sanitized JSON parses to the same
    exact value as the original JSON.
    
    Tests:
    
        autoninja -C out/Release content_shell base base_unittests services services_unittests
        out/Release/base_unittests --gtest_filter=JSONParserTest.*:JSONReaderTest.*:JSONStringEscapeTest.*:StringUtilTest.IsStringUTF8
        out/Release/services_unittests --gtest_filter=DataDecoderJsonSanitizerTest.Unicode
        third_party/blink/tools/run_web_tests.py -t Release http/tests/devtools/runtime/runtime-evaluate-bad-unicode.js
    
        autoninja -C out/Android services services_unittests
        out/Android/services_unittests --gtest_filter=DataDecoderJsonSanitizerTest.Unicode
    
    [1]: https://tools.ietf.org/html/rfc4627#section-2.5
    [2]: https://ecma-international.org/publications/standards/Ecma-404.htm
    [3]: https://chromium-review.googlesource.com/c/1352588
    
    Bug: chromium:848823, chromium:1042269
    Task-number: QTBUG-84340
    Change-Id: I1299c31cade1afb2a7cf85cf665d1925bc22be6e
    Reviewed-by: Allan Sandfeld Jensen <allan.jensen@qt.io>

diff --git a/src/3rdparty/chromium/base/json/json_parser.cc b/src/3rdparty/chromium/base/json/json_parser.cc
index 65a4b7dd02e..b1cc5c53101 100644
--- a/src/3rdparty/chromium/base/json/json_parser.cc
+++ b/src/3rdparty/chromium/base/json/json_parser.cc
@@ -114,7 +114,7 @@ JSONParser::StringBuilder& JSONParser::StringBuilder::operator=(
     StringBuilder&& other) = default;
 
 void JSONParser::StringBuilder::Append(uint32_t point) {
-  DCHECK(IsValidCharacter(point));
+  DCHECK(IsValidCodepoint(point));
 
   if (point < kExtendedASCIIStart && !string_) {
     DCHECK_EQ(static_cast<char>(point), pos_[length_]);
@@ -416,7 +416,6 @@ Optional<Value> JSONParser::ConsumeString() {
   StringBuilder string;
   if (!ConsumeStringRaw(&string))
     return nullopt;
-
   return Value(string.DestructiveAsString());
 }
 
@@ -434,10 +433,9 @@ bool JSONParser::ConsumeStringRaw(StringBuilder* out) {
   while (PeekChar()) {
     uint32_t next_char = 0;
     if (!ReadUnicodeCharacter(input_.data(),
-                              static_cast<int32_t>(input_.length()),
-                              &index_,
+                              static_cast<int32_t>(input_.length()), &index_,
                               &next_char) ||
-        !IsValidCharacter(next_char)) {
+        !IsValidCodepoint(next_char)) {
       if ((options_ & JSON_REPLACE_INVALID_CHARACTERS) == 0) {
         ReportError(JSONReader::JSON_UNSUPPORTED_ENCODING, 1);
         return false;
@@ -561,8 +559,12 @@ bool JSONParser::DecodeUTF16(uint32_t* out_code_point) {
 
     // Make sure that the token has more characters to consume the
     // lower surrogate.
-    if (!ConsumeIfMatch("\\u"))
-      return false;
+    if (!ConsumeIfMatch("\\u")) {
+      if ((options_ & JSON_REPLACE_INVALID_CHARACTERS) == 0)
+        return false;
+      *out_code_point = kUnicodeReplacementPoint;
+      return true;
+    }
 
     escape_sequence = ConsumeChars(4);
     if (!escape_sequence)
@@ -572,25 +574,20 @@ bool JSONParser::DecodeUTF16(uint32_t* out_code_point) {
     if (!HexStringToInt(*escape_sequence, &code_unit16_low))
       return false;
 
-    if (!CBU16_IS_TRAIL(code_unit16_low))
-      return false;
+    if (!CBU16_IS_TRAIL(code_unit16_low)) {
+      if ((options_ & JSON_REPLACE_INVALID_CHARACTERS) == 0)
+        return false;
+      *out_code_point = kUnicodeReplacementPoint;
+      return true;
+    }
 
     uint32_t code_point =
         CBU16_GET_SUPPLEMENTARY(code_unit16_high, code_unit16_low);
-    if (!IsValidCharacter(code_point))
-      return false;
 
     *out_code_point = code_point;
   } else {
     // Not a surrogate.
     DCHECK(CBU16_IS_SINGLE(code_unit16_high));
-    if (!IsValidCharacter(code_unit16_high)) {
-      if ((options_ & JSON_REPLACE_INVALID_CHARACTERS) == 0) {
-        return false;
-      }
-      *out_code_point = kUnicodeReplacementPoint;
-      return true;
-    }
 
     *out_code_point = code_unit16_high;
   }
diff --git a/src/3rdparty/chromium/base/json/json_parser_unittest.cc b/src/3rdparty/chromium/base/json/json_parser_unittest.cc
index 2b792df046c..6ce5bab6519 100644
--- a/src/3rdparty/chromium/base/json/json_parser_unittest.cc
+++ b/src/3rdparty/chromium/base/json/json_parser_unittest.cc
@@ -310,12 +310,6 @@ TEST_F(JSONParserTest, ErrorMessages) {
   EXPECT_EQ(JSONParser::FormatErrorMessage(1, 7, JSONReader::kInvalidEscape),
             root.error_message);
   EXPECT_EQ(JSONReader::JSON_INVALID_ESCAPE, root.error_code);
-
-  root = JSONReader::ReadAndReturnValueWithError(("[\"\\ufffe\"]"),
-                                                 JSON_PARSE_RFC);
-  EXPECT_EQ(JSONParser::FormatErrorMessage(1, 8, JSONReader::kInvalidEscape),
-            root.error_message);
-  EXPECT_EQ(JSONReader::JSON_INVALID_ESCAPE, root.error_code);
 }
 
 TEST_F(JSONParserTest, Decode4ByteUtf8Char) {
@@ -331,14 +325,43 @@ TEST_F(JSONParserTest, Decode4ByteUtf8Char) {
 TEST_F(JSONParserTest, DecodeUnicodeNonCharacter) {
   // Tests Unicode code points (encoded as escaped UTF-16) that are not valid
   // characters.
-  EXPECT_FALSE(JSONReader::Read("[\"\\ufdd0\"]"));
-  EXPECT_FALSE(JSONReader::Read("[\"\\ufffe\"]"));
-  EXPECT_FALSE(JSONReader::Read("[\"\\ud83f\\udffe\"]"));
-
-  EXPECT_TRUE(
-      JSONReader::Read("[\"\\ufdd0\"]", JSON_REPLACE_INVALID_CHARACTERS));
-  EXPECT_TRUE(
-      JSONReader::Read("[\"\\ufffe\"]", JSON_REPLACE_INVALID_CHARACTERS));
+  EXPECT_TRUE(JSONReader::Read("[\"\\uFDD0\"]"));         // U+FDD0
+  EXPECT_TRUE(JSONReader::Read("[\"\\uFDDF\"]"));         // U+FDDF
+  EXPECT_TRUE(JSONReader::Read("[\"\\uFDEF\"]"));         // U+FDEF
+  EXPECT_TRUE(JSONReader::Read("[\"\\uFFFE\"]"));         // U+FFFE
+  EXPECT_TRUE(JSONReader::Read("[\"\\uFFFF\"]"));         // U+FFFF
+  EXPECT_TRUE(JSONReader::Read("[\"\\uD83F\\uDFFE\"]"));  // U+01FFFE
+  EXPECT_TRUE(JSONReader::Read("[\"\\uD83F\\uDFFF\"]"));  // U+01FFFF
+  EXPECT_TRUE(JSONReader::Read("[\"\\uD87F\\uDFFE\"]"));  // U+02FFFE
+  EXPECT_TRUE(JSONReader::Read("[\"\\uD87F\\uDFFF\"]"));  // U+02FFFF
+  EXPECT_TRUE(JSONReader::Read("[\"\\uD8BF\\uDFFE\"]"));  // U+03FFFE
+  EXPECT_TRUE(JSONReader::Read("[\"\\uD8BF\\uDFFF\"]"));  // U+03FFFF
+  EXPECT_TRUE(JSONReader::Read("[\"\\uD8FF\\uDFFE\"]"));  // U+04FFFE
+  EXPECT_TRUE(JSONReader::Read("[\"\\uD8FF\\uDFFF\"]"));  // U+04FFFF
+  EXPECT_TRUE(JSONReader::Read("[\"\\uD93F\\uDFFE\"]"));  // U+05FFFE
+  EXPECT_TRUE(JSONReader::Read("[\"\\uD93F\\uDFFF\"]"));  // U+05FFFF
+  EXPECT_TRUE(JSONReader::Read("[\"\\uD97F\\uDFFE\"]"));  // U+06FFFE
+  EXPECT_TRUE(JSONReader::Read("[\"\\uD97F\\uDFFF\"]"));  // U+06FFFF
+  EXPECT_TRUE(JSONReader::Read("[\"\\uD9BF\\uDFFE\"]"));  // U+07FFFE
+  EXPECT_TRUE(JSONReader::Read("[\"\\uD9BF\\uDFFF\"]"));  // U+07FFFF
+  EXPECT_TRUE(JSONReader::Read("[\"\\uD9FF\\uDFFE\"]"));  // U+08FFFE
+  EXPECT_TRUE(JSONReader::Read("[\"\\uD9FF\\uDFFF\"]"));  // U+08FFFF
+  EXPECT_TRUE(JSONReader::Read("[\"\\uDA3F\\uDFFE\"]"));  // U+09FFFE
+  EXPECT_TRUE(JSONReader::Read("[\"\\uDA3F\\uDFFF\"]"));  // U+09FFFF
+  EXPECT_TRUE(JSONReader::Read("[\"\\uDA7F\\uDFFE\"]"));  // U+0AFFFE
+  EXPECT_TRUE(JSONReader::Read("[\"\\uDA7F\\uDFFF\"]"));  // U+0AFFFF
+  EXPECT_TRUE(JSONReader::Read("[\"\\uDABF\\uDFFE\"]"));  // U+0BFFFE
+  EXPECT_TRUE(JSONReader::Read("[\"\\uDABF\\uDFFF\"]"));  // U+0BFFFF
+  EXPECT_TRUE(JSONReader::Read("[\"\\uDAFF\\uDFFE\"]"));  // U+0CFFFE
+  EXPECT_TRUE(JSONReader::Read("[\"\\uDAFF\\uDFFF\"]"));  // U+0CFFFF
+  EXPECT_TRUE(JSONReader::Read("[\"\\uDB3F\\uDFFE\"]"));  // U+0DFFFE
+  EXPECT_TRUE(JSONReader::Read("[\"\\uDB3F\\uDFFF\"]"));  // U+0DFFFF
+  EXPECT_TRUE(JSONReader::Read("[\"\\uDB7F\\uDFFE\"]"));  // U+0EFFFE
+  EXPECT_TRUE(JSONReader::Read("[\"\\uDB7F\\uDFFF\"]"));  // U+0EFFFF
+  EXPECT_TRUE(JSONReader::Read("[\"\\uDBBF\\uDFFE\"]"));  // U+0FFFFE
+  EXPECT_TRUE(JSONReader::Read("[\"\\uDBBF\\uDFFF\"]"));  // U+0FFFFF
+  EXPECT_TRUE(JSONReader::Read("[\"\\uDBFF\\uDFFE\"]"));  // U+10FFFE
+  EXPECT_TRUE(JSONReader::Read("[\"\\uDBFF\\uDFFF\"]"));  // U+10FFFF
 }
 
 TEST_F(JSONParserTest, DecodeNegativeEscapeSequence) {
@@ -346,28 +369,31 @@ TEST_F(JSONParserTest, DecodeNegativeEscapeSequence) {
   EXPECT_FALSE(JSONReader::Read("[\"\\u-00A\"]"));
 }
 
-// Verifies invalid utf-8 characters are replaced.
+// Verifies invalid code points are replaced.
 TEST_F(JSONParserTest, ReplaceInvalidCharacters) {
-  const std::string bogus_char = "ó¿¿¿";
-  const std::string quoted_bogus_char = "\"" + bogus_char + "\"";
+  // U+D800 is a lone surrogate.
+  const std::string invalid = "\"\xED\xA0\x80\"";
   std::unique_ptr<JSONParser> parser(
-      NewTestParser(quoted_bogus_char, JSON_REPLACE_INVALID_CHARACTERS));
+      NewTestParser(invalid, JSON_REPLACE_INVALID_CHARACTERS));
   Optional<Value> value(parser->ConsumeString());
   ASSERT_TRUE(value);
   std::string str;
   EXPECT_TRUE(value->GetAsString(&str));
-  EXPECT_EQ(kUnicodeReplacementString, str);
+  // Expect three U+FFFD (one for each UTF-8 byte in the invalid code
+  // point).
+  EXPECT_EQ("\xEF\xBF\xBD\xEF\xBF\xBD\xEF\xBF\xBD", str);
 }
 
 TEST_F(JSONParserTest, ReplaceInvalidUTF16EscapeSequence) {
-  const std::string invalid = "\"\\ufffe\"";
+  // U+D800 is a lone surrogate.
+  const std::string invalid = "\"_\\uD800_\"";
   std::unique_ptr<JSONParser> parser(
       NewTestParser(invalid, JSON_REPLACE_INVALID_CHARACTERS));
   Optional<Value> value(parser->ConsumeString());
   ASSERT_TRUE(value);
   std::string str;
   EXPECT_TRUE(value->GetAsString(&str));
-  EXPECT_EQ(kUnicodeReplacementString, str);
+  EXPECT_EQ("_\xEF\xBF\xBD_", str);
 }
 
 TEST_F(JSONParserTest, ParseNumberErrors) {
diff --git a/src/3rdparty/chromium/base/json/json_reader.h b/src/3rdparty/chromium/base/json/json_reader.h
index 3eee07ccc3b..a511e0234f4 100644
--- a/src/3rdparty/chromium/base/json/json_reader.h
+++ b/src/3rdparty/chromium/base/json/json_reader.h
@@ -51,9 +51,10 @@ enum JSONParserOptions {
   // Allows commas to exist after the last element in structures.
   JSON_ALLOW_TRAILING_COMMAS = 1 << 0,
 
-  // If set the parser replaces invalid characters with the Unicode replacement
-  // character (U+FFFD). If not set, invalid characters trigger a hard error and
-  // parsing fails.
+  // If set the parser replaces invalid code points (i.e. lone
+  // surrogates) with the Unicode replacement character (U+FFFD). If
+  // not set, invalid code points trigger a hard error and parsing
+  // fails.
   JSON_REPLACE_INVALID_CHARACTERS = 1 << 1,
 };
 
diff --git a/src/3rdparty/chromium/base/json/json_reader_unittest.cc b/src/3rdparty/chromium/base/json/json_reader_unittest.cc
index 186a6f1dce3..73fe9d97514 100644
--- a/src/3rdparty/chromium/base/json/json_reader_unittest.cc
+++ b/src/3rdparty/chromium/base/json/json_reader_unittest.cc
@@ -479,6 +479,50 @@ TEST(JSONReaderTest, UTF8Input) {
   const std::string* maybe_string = root->FindStringKey("path");
   ASSERT_TRUE(maybe_string);
   EXPECT_EQ("/tmp/\xC3\xA0\xC3\xA8\xC3\xB2.png", *maybe_string);
+
+  // JSON can encode non-characters.
+  const char* const noncharacters[] = {
+      "\"\xEF\xB7\x90\"",      // U+FDD0
+      "\"\xEF\xB7\x9F\"",      // U+FDDF
+      "\"\xEF\xB7\xAF\"",      // U+FDEF
+      "\"\xEF\xBF\xBE\"",      // U+FFFE
+      "\"\xEF\xBF\xBF\"",      // U+FFFF
+      "\"\xF0\x9F\xBF\xBE\"",  // U+01FFFE
+      "\"\xF0\x9F\xBF\xBF\"",  // U+01FFFF
+      "\"\xF0\xAF\xBF\xBE\"",  // U+02FFFE
+      "\"\xF0\xAF\xBF\xBF\"",  // U+02FFFF
+      "\"\xF0\xBF\xBF\xBE\"",  // U+03FFFE
+      "\"\xF0\xBF\xBF\xBF\"",  // U+03FFFF
+      "\"\xF1\x8F\xBF\xBE\"",  // U+04FFFE
+      "\"\xF1\x8F\xBF\xBF\"",  // U+04FFFF
+      "\"\xF1\x9F\xBF\xBE\"",  // U+05FFFE
+      "\"\xF1\x9F\xBF\xBF\"",  // U+05FFFF
+      "\"\xF1\xAF\xBF\xBE\"",  // U+06FFFE
+      "\"\xF1\xAF\xBF\xBF\"",  // U+06FFFF
+      "\"\xF1\xBF\xBF\xBE\"",  // U+07FFFE
+      "\"\xF1\xBF\xBF\xBF\"",  // U+07FFFF
+      "\"\xF2\x8F\xBF\xBE\"",  // U+08FFFE
+      "\"\xF2\x8F\xBF\xBF\"",  // U+08FFFF
+      "\"\xF2\x9F\xBF\xBE\"",  // U+09FFFE
+      "\"\xF2\x9F\xBF\xBF\"",  // U+09FFFF
+      "\"\xF2\xAF\xBF\xBE\"",  // U+0AFFFE
+      "\"\xF2\xAF\xBF\xBF\"",  // U+0AFFFF
+      "\"\xF2\xBF\xBF\xBE\"",  // U+0BFFFE
+      "\"\xF2\xBF\xBF\xBF\"",  // U+0BFFFF
+      "\"\xF3\x8F\xBF\xBE\"",  // U+0CFFFE
+      "\"\xF3\x8F\xBF\xBF\"",  // U+0CFFFF
+      "\"\xF3\x9F\xBF\xBE\"",  // U+0DFFFE
+      "\"\xF3\x9F\xBF\xBF\"",  // U+0DFFFF
+      "\"\xF3\xAF\xBF\xBE\"",  // U+0EFFFE
+      "\"\xF3\xAF\xBF\xBF\"",  // U+0EFFFF
+      "\"\xF3\xBF\xBF\xBE\"",  // U+0FFFFE
+      "\"\xF3\xBF\xBF\xBF\"",  // U+0FFFFF
+      "\"\xF4\x8F\xBF\xBE\"",  // U+10FFFE
+      "\"\xF4\x8F\xBF\xBF\"",  // U+10FFFF
+  };
+  for (auto* noncharacter : noncharacters) {
+    EXPECT_TRUE(JSONReader::Read(noncharacter));
+  }
 }
 
 TEST(JSONReaderTest, InvalidUTF8Input) {
@@ -514,12 +558,12 @@ TEST(JSONReaderTest, InvalidUTF16Escapes) {
       "\"\\uzz89\"",         // Invalid scalar.
       "\"\\ud83d\\udca\"",   // Invalid lower surrogate.
       "\"\\ud83d\\ud83d\"",  // Invalid lower surrogate.
-      "\"\\ud83d\\uaaaZ\""   // Invalid lower surrogate.
+      "\"\\ud83d\\uaaaZ\"",  // Invalid lower surrogate.
       "\"\\ud83foo\"",       // No lower surrogate.
-      "\"\\ud83d\\foo\""     // No lower surrogate.
-      "\"\\ud83\\foo\""      // Invalid upper surrogate.
-      "\"\\ud83d\\u1\""      // No lower surrogate.
-      "\"\\ud83\\u1\""       // Invalid upper surrogate.
+      "\"\\ud83d\\foo\"",    // No lower surrogate.
+      "\"\\ud83\\foo\"",     // Invalid upper surrogate.
+      "\"\\ud83d\\u1\"",     // No lower surrogate.
+      "\"\\ud83\\u1\"",      // Invalid upper surrogate.
   };
   Optional<Value> root;
   for (auto* i : cases) {
diff --git a/src/3rdparty/chromium/base/json/string_escape.cc b/src/3rdparty/chromium/base/json/string_escape.cc
index 34374874c30..d1253e24cd4 100644
--- a/src/3rdparty/chromium/base/json/string_escape.cc
+++ b/src/3rdparty/chromium/base/json/string_escape.cc
@@ -93,7 +93,7 @@ bool EscapeJSONStringImpl(const S& str, bool put_in_quotes, std::string* dest) {
     uint32_t code_point;
     if (!ReadUnicodeCharacter(str.data(), length, &i, &code_point) ||
         code_point == static_cast<decltype(code_point)>(CBU_SENTINEL) ||
-        !IsValidCharacter(code_point)) {
+        !IsValidCodepoint(code_point)) {
       code_point = kReplacementCodePoint;
       did_replacement = true;
     }
diff --git a/src/3rdparty/chromium/base/json/string_escape_unittest.cc b/src/3rdparty/chromium/base/json/string_escape_unittest.cc
index eae302ccb9b..135d761568d 100644
--- a/src/3rdparty/chromium/base/json/string_escape_unittest.cc
+++ b/src/3rdparty/chromium/base/json/string_escape_unittest.cc
@@ -23,10 +23,46 @@ TEST(JSONStringEscapeTest, EscapeUTF8) {
       {"b\x0f\x7f\xf0\xff!",  // \xf0\xff is not a valid UTF-8 unit.
        "b\\u000F\x7F\xEF\xBF\xBD\xEF\xBF\xBD!"},
       {"c<>d", "c\\u003C>d"},
-      {"Hello\xe2\x80\xa8world", "Hello\\u2028world"},
-      {"\xe2\x80\xa9purple", "\\u2029purple"},
-      {"\xF3\xBF\xBF\xBF", "\xEF\xBF\xBD"},
-      {"\uFFFF", "\xEF\xBF\xBD"},
+      {"Hello\xE2\x80\xA8world", "Hello\\u2028world"},  // U+2028
+      {"\xE2\x80\xA9purple", "\\u2029purple"},          // U+2029
+      // Unicode non-characters.
+      {"\xEF\xB7\x90", "\xEF\xB7\x90"},          // U+FDD0
+      {"\xEF\xB7\x9F", "\xEF\xB7\x9F"},          // U+FDDF
+      {"\xEF\xB7\xAF", "\xEF\xB7\xAF"},          // U+FDEF
+      {"\xEF\xBF\xBE", "\xEF\xBF\xBE"},          // U+FFFE
+      {"\xEF\xBF\xBF", "\xEF\xBF\xBF"},          // U+FFFF
+      {"\xF0\x9F\xBF\xBE", "\xF0\x9F\xBF\xBE"},  // U+01FFFE
+      {"\xF0\x9F\xBF\xBF", "\xF0\x9F\xBF\xBF"},  // U+01FFFF
+      {"\xF0\xAF\xBF\xBE", "\xF0\xAF\xBF\xBE"},  // U+02FFFE
+      {"\xF0\xAF\xBF\xBF", "\xF0\xAF\xBF\xBF"},  // U+02FFFF
+      {"\xF0\xBF\xBF\xBE", "\xF0\xBF\xBF\xBE"},  // U+03FFFE
+      {"\xF0\xBF\xBF\xBF", "\xF0\xBF\xBF\xBF"},  // U+03FFFF
+      {"\xF1\x8F\xBF\xBE", "\xF1\x8F\xBF\xBE"},  // U+04FFFE
+      {"\xF1\x8F\xBF\xBF", "\xF1\x8F\xBF\xBF"},  // U+04FFFF
+      {"\xF1\x9F\xBF\xBE", "\xF1\x9F\xBF\xBE"},  // U+05FFFE
+      {"\xF1\x9F\xBF\xBF", "\xF1\x9F\xBF\xBF"},  // U+05FFFF
+      {"\xF1\xAF\xBF\xBE", "\xF1\xAF\xBF\xBE"},  // U+06FFFE
+      {"\xF1\xAF\xBF\xBF", "\xF1\xAF\xBF\xBF"},  // U+06FFFF
+      {"\xF1\xBF\xBF\xBE", "\xF1\xBF\xBF\xBE"},  // U+07FFFE
+      {"\xF1\xBF\xBF\xBF", "\xF1\xBF\xBF\xBF"},  // U+07FFFF
+      {"\xF2\x8F\xBF\xBE", "\xF2\x8F\xBF\xBE"},  // U+08FFFE
+      {"\xF2\x8F\xBF\xBF", "\xF2\x8F\xBF\xBF"},  // U+08FFFF
+      {"\xF2\x9F\xBF\xBE", "\xF2\x9F\xBF\xBE"},  // U+09FFFE
+      {"\xF2\x9F\xBF\xBF", "\xF2\x9F\xBF\xBF"},  // U+09FFFF
+      {"\xF2\xAF\xBF\xBE", "\xF2\xAF\xBF\xBE"},  // U+0AFFFE
+      {"\xF2\xAF\xBF\xBF", "\xF2\xAF\xBF\xBF"},  // U+0AFFFF
+      {"\xF2\xBF\xBF\xBE", "\xF2\xBF\xBF\xBE"},  // U+0BFFFE
+      {"\xF2\xBF\xBF\xBF", "\xF2\xBF\xBF\xBF"},  // U+0BFFFF
+      {"\xF3\x8F\xBF\xBE", "\xF3\x8F\xBF\xBE"},  // U+0CFFFE
+      {"\xF3\x8F\xBF\xBF", "\xF3\x8F\xBF\xBF"},  // U+0CFFFF
+      {"\xF3\x9F\xBF\xBE", "\xF3\x9F\xBF\xBE"},  // U+0DFFFE
+      {"\xF3\x9F\xBF\xBF", "\xF3\x9F\xBF\xBF"},  // U+0DFFFF
+      {"\xF3\xAF\xBF\xBE", "\xF3\xAF\xBF\xBE"},  // U+0EFFFE
+      {"\xF3\xAF\xBF\xBF", "\xF3\xAF\xBF\xBF"},  // U+0EFFFF
+      {"\xF3\xBF\xBF\xBE", "\xF3\xBF\xBF\xBE"},  // U+0FFFFE
+      {"\xF3\xBF\xBF\xBF", "\xF3\xBF\xBF\xBF"},  // U+0FFFFF
+      {"\xF4\x8F\xBF\xBE", "\xF4\x8F\xBF\xBE"},  // U+10FFFE
+      {"\xF4\x8F\xBF\xBF", "\xF4\x8F\xBF\xBF"},  // U+10FFFF
   };
 
   for (const auto& i : cases) {
@@ -36,29 +72,29 @@ TEST(JSONStringEscapeTest, EscapeUTF8) {
     std::string out;
     EscapeJSONString(in_ptr, false, &out);
     EXPECT_EQ(std::string(i.escaped), out);
-    EXPECT_TRUE(IsStringUTF8(out));
+    EXPECT_TRUE(IsStringUTF8AllowingNoncharacters(out));
 
     out.erase();
     EscapeJSONString(in_str, false, &out);
     EXPECT_EQ(std::string(i.escaped), out);
-    EXPECT_TRUE(IsStringUTF8(out));
+    EXPECT_TRUE(IsStringUTF8AllowingNoncharacters(out));
 
     std::string fooout = GetQuotedJSONString(in_str);
     EXPECT_EQ("\"" + std::string(i.escaped) + "\"", fooout);
-    EXPECT_TRUE(IsStringUTF8(out));
+    EXPECT_TRUE(IsStringUTF8AllowingNoncharacters(out));
   }
 
   std::string in = cases[0].to_escape;
   std::string out;
   EscapeJSONString(in, false, &out);
-  EXPECT_TRUE(IsStringUTF8(out));
+  EXPECT_TRUE(IsStringUTF8AllowingNoncharacters(out));
 
   // test quoting
   std::string out_quoted;
   EscapeJSONString(in, true, &out_quoted);
   EXPECT_EQ(out.length() + 2, out_quoted.length());
   EXPECT_EQ(out_quoted.find(out), 1U);
-  EXPECT_TRUE(IsStringUTF8(out_quoted));
+  EXPECT_TRUE(IsStringUTF8AllowingNoncharacters(out_quoted));
 
   // now try with a NULL in the string
   std::string null_prepend = "test";
@@ -69,7 +105,7 @@ TEST(JSONStringEscapeTest, EscapeUTF8) {
   out.clear();
   EscapeJSONString(in, false, &out);
   EXPECT_EQ(expected, out);
-  EXPECT_TRUE(IsStringUTF8(out));
+  EXPECT_TRUE(IsStringUTF8AllowingNoncharacters(out));
 }
 
 TEST(JSONStringEscapeTest, EscapeUTF16) {
@@ -80,11 +116,48 @@ TEST(JSONStringEscapeTest, EscapeUTF16) {
       {L"b\uffb1\u00ff", "b\xEF\xBE\xB1\xC3\xBF"},
       {L"\b\001aZ\"\\wee", "\\b\\u0001aZ\\\"\\\\wee"},
       {L"a\b\f\n\r\t\v\1\\.\"z", "a\\b\\f\\n\\r\\t\\u000B\\u0001\\\\.\\\"z"},
-      {L"b\x0f\x7f\xf0\xff!", "b\\u000F\x7F\xC3\xB0\xC3\xBF!"},
+      {L"b\x0F\x7F\xF0\xFF!", "b\\u000F\x7F\xC3\xB0\xC3\xBF!"},
       {L"c<>d", "c\\u003C>d"},
       {L"Hello\u2028world", "Hello\\u2028world"},
       {L"\u2029purple", "\\u2029purple"},
-      {L"\uFFFF", "\xEF\xBF\xBD"},
+      // Unicode non-characters.
+      {L"\uFDD0", "\xEF\xB7\x90"},          // U+FDD0
+      {L"\uFDDF", "\xEF\xB7\x9F"},          // U+FDDF
+      {L"\uFDEF", "\xEF\xB7\xAF"},          // U+FDEF
+      {L"\uFFFE", "\xEF\xBF\xBE"},          // U+FFFE
+      {L"\uFFFF", "\xEF\xBF\xBF"},          // U+FFFF
+      {L"\U0001FFFE", "\xF0\x9F\xBF\xBE"},  // U+01FFFE
+      {L"\U0001FFFF", "\xF0\x9F\xBF\xBF"},  // U+01FFFF
+      {L"\U0002FFFE", "\xF0\xAF\xBF\xBE"},  // U+02FFFE
+      {L"\U0002FFFF", "\xF0\xAF\xBF\xBF"},  // U+02FFFF
+      {L"\U0003FFFE", "\xF0\xBF\xBF\xBE"},  // U+03FFFE
+      {L"\U0003FFFF", "\xF0\xBF\xBF\xBF"},  // U+03FFFF
+      {L"\U0004FFFE", "\xF1\x8F\xBF\xBE"},  // U+04FFFE
+      {L"\U0004FFFF", "\xF1\x8F\xBF\xBF"},  // U+04FFFF
+      {L"\U0005FFFE", "\xF1\x9F\xBF\xBE"},  // U+05FFFE
+      {L"\U0005FFFF", "\xF1\x9F\xBF\xBF"},  // U+05FFFF
+      {L"\U0006FFFE", "\xF1\xAF\xBF\xBE"},  // U+06FFFE
+      {L"\U0006FFFF", "\xF1\xAF\xBF\xBF"},  // U+06FFFF
+      {L"\U0007FFFE", "\xF1\xBF\xBF\xBE"},  // U+07FFFE
+      {L"\U0007FFFF", "\xF1\xBF\xBF\xBF"},  // U+07FFFF
+      {L"\U0008FFFE", "\xF2\x8F\xBF\xBE"},  // U+08FFFE
+      {L"\U0008FFFF", "\xF2\x8F\xBF\xBF"},  // U+08FFFF
+      {L"\U0009FFFE", "\xF2\x9F\xBF\xBE"},  // U+09FFFE
+      {L"\U0009FFFF", "\xF2\x9F\xBF\xBF"},  // U+09FFFF
+      {L"\U000AFFFE", "\xF2\xAF\xBF\xBE"},  // U+0AFFFE
+      {L"\U000AFFFF", "\xF2\xAF\xBF\xBF"},  // U+0AFFFF
+      {L"\U000BFFFE", "\xF2\xBF\xBF\xBE"},  // U+0BFFFE
+      {L"\U000BFFFF", "\xF2\xBF\xBF\xBF"},  // U+0BFFFF
+      {L"\U000CFFFE", "\xF3\x8F\xBF\xBE"},  // U+0CFFFE
+      {L"\U000CFFFF", "\xF3\x8F\xBF\xBF"},  // U+0CFFFF
+      {L"\U000DFFFE", "\xF3\x9F\xBF\xBE"},  // U+0DFFFE
+      {L"\U000DFFFF", "\xF3\x9F\xBF\xBF"},  // U+0DFFFF
+      {L"\U000EFFFE", "\xF3\xAF\xBF\xBE"},  // U+0EFFFE
+      {L"\U000EFFFF", "\xF3\xAF\xBF\xBF"},  // U+0EFFFF
+      {L"\U000FFFFE", "\xF3\xBF\xBF\xBE"},  // U+0FFFFE
+      {L"\U000FFFFF", "\xF3\xBF\xBF\xBF"},  // U+0FFFFF
+      {L"\U0010FFFE", "\xF4\x8F\xBF\xBE"},  // U+10FFFE
+      {L"\U0010FFFF", "\xF4\x8F\xBF\xBF"},  // U+10FFFF
   };
 
   for (const auto& i : cases) {
@@ -93,24 +166,24 @@ TEST(JSONStringEscapeTest, EscapeUTF16) {
     std::string out;
     EscapeJSONString(in, false, &out);
     EXPECT_EQ(std::string(i.escaped), out);
-    EXPECT_TRUE(IsStringUTF8(out));
+    EXPECT_TRUE(IsStringUTF8AllowingNoncharacters(out));
 
     out = GetQuotedJSONString(in);
     EXPECT_EQ("\"" + std::string(i.escaped) + "\"", out);
-    EXPECT_TRUE(IsStringUTF8(out));
+    EXPECT_TRUE(IsStringUTF8AllowingNoncharacters(out));
   }
 
   string16 in = WideToUTF16(cases[0].to_escape);
   std::string out;
   EscapeJSONString(in, false, &out);
-  EXPECT_TRUE(IsStringUTF8(out));
+  EXPECT_TRUE(IsStringUTF8AllowingNoncharacters(out));
 
   // test quoting
   std::string out_quoted;
   EscapeJSONString(in, true, &out_quoted);
   EXPECT_EQ(out.length() + 2, out_quoted.length());
   EXPECT_EQ(out_quoted.find(out), 1U);
-  EXPECT_TRUE(IsStringUTF8(out));
+  EXPECT_TRUE(IsStringUTF8AllowingNoncharacters(out));
 
   // now try with a NULL in the string
   string16 null_prepend = WideToUTF16(L"test");
@@ -121,7 +194,7 @@ TEST(JSONStringEscapeTest, EscapeUTF16) {
   out.clear();
   EscapeJSONString(in, false, &out);
   EXPECT_EQ(expected, out);
-  EXPECT_TRUE(IsStringUTF8(out));
+  EXPECT_TRUE(IsStringUTF8AllowingNoncharacters(out));
 }
 
 TEST(JSONStringEscapeTest, EscapeUTF16OutsideBMP) {
@@ -170,7 +243,7 @@ TEST(JSONStringEscapeTest, EscapeBytes) {
 
   for (const auto& i : cases) {
     std::string in = std::string(i.to_escape);
-    EXPECT_FALSE(IsStringUTF8(in));
+    EXPECT_FALSE(IsStringUTF8AllowingNoncharacters(in));
 
     EXPECT_EQ(std::string(i.escaped),
               EscapeBytesAsInvalidJSONString(in, false));
@@ -180,7 +253,7 @@ TEST(JSONStringEscapeTest, EscapeBytes) {
 
   const char kEmbedNull[] = { '\xab', '\x39', '\0', '\x9f', '\xab' };
   std::string in(kEmbedNull, base::size(kEmbedNull));
-  EXPECT_FALSE(IsStringUTF8(in));
+  EXPECT_FALSE(IsStringUTF8AllowingNoncharacters(in));
   EXPECT_EQ(std::string("\\u00AB9\\u0000\\u009F\\u00AB"),
             EscapeBytesAsInvalidJSONString(in, false));
 }
diff --git a/src/3rdparty/chromium/base/strings/string_util.cc b/src/3rdparty/chromium/base/strings/string_util.cc
index 4a458420b96..7e140fae48b 100644
--- a/src/3rdparty/chromium/base/strings/string_util.cc
+++ b/src/3rdparty/chromium/base/strings/string_util.cc
@@ -505,20 +505,29 @@ bool IsStringASCII(WStringPiece str) {
 }
 #endif
 
-bool IsStringUTF8(StringPiece str) {
-  const char *src = str.data();
+template <bool (*Validator)(uint32_t)>
+inline static bool DoIsStringUTF8(StringPiece str) {
+  const char* src = str.data();
   int32_t src_len = static_cast<int32_t>(str.length());
   int32_t char_index = 0;
 
   while (char_index < src_len) {
     int32_t code_point;
     CBU8_NEXT(src, char_index, src_len, code_point);
-    if (!IsValidCharacter(code_point))
+    if (!Validator(code_point))
       return false;
   }
   return true;
 }
 
+bool IsStringUTF8(StringPiece str) {
+  return DoIsStringUTF8<IsValidCharacter>(str);
+}
+
+bool IsStringUTF8AllowingNoncharacters(StringPiece str) {
+  return DoIsStringUTF8<IsValidCodepoint>(str);
+}
+
 // Implementation note: Normally this function will be called with a hardcoded
 // constant for the lowercase_ascii parameter. Constructing a StringPiece from
 // a C constant requires running strlen, so the result will be two passes
diff --git a/src/3rdparty/chromium/base/strings/string_util.h b/src/3rdparty/chromium/base/strings/string_util.h
index b4348995a04..f9f5e10ade9 100644
--- a/src/3rdparty/chromium/base/strings/string_util.h
+++ b/src/3rdparty/chromium/base/strings/string_util.h
@@ -328,21 +328,23 @@ BASE_EXPORT bool ContainsOnlyChars(StringPiece input, StringPiece characters);
 BASE_EXPORT bool ContainsOnlyChars(StringPiece16 input,
                                    StringPiece16 characters);
 
-// Returns true if the specified string matches the criteria. How can a wide
-// string be 8-bit or UTF8? It contains only characters that are < 256 (in the
-// first case) or characters that use only 8-bits and whose 8-bit
-// representation looks like a UTF-8 string (the second case).
-//
-// Note that IsStringUTF8 checks not only if the input is structurally
-// valid but also if it doesn't contain any non-character codepoint
-// (e.g. U+FFFE). It's done on purpose because all the existing callers want
-// to have the maximum 'discriminating' power from other encodings. If
-// there's a use case for just checking the structural validity, we have to
-// add a new function for that.
-//
-// IsStringASCII assumes the input is likely all ASCII, and does not leave early
-// if it is not the case.
+// Returns true if |str| is structurally valid UTF-8 and also doesn't
+// contain any non-character code point (e.g. U+10FFFE). Prohibiting
+// non-characters increases the likelihood of detecting non-UTF-8 in
+// real-world text, for callers which do not need to accept
+// non-characters in strings.
 BASE_EXPORT bool IsStringUTF8(StringPiece str);
+
+// Returns true if |str| contains valid UTF-8, allowing non-character
+// code points.
+BASE_EXPORT bool IsStringUTF8AllowingNoncharacters(StringPiece str);
+
+// Returns true if |str| contains only valid ASCII character values.
+// Note 1: IsStringASCII executes in time determined solely by the
+// length of the string, not by its contents, so it is robust against
+// timing attacks for all strings of equal length.
+// Note 2: IsStringASCII assumes the input is likely all ASCII, and
+// does not leave early if it is not the case.
 BASE_EXPORT bool IsStringASCII(StringPiece str);
 BASE_EXPORT bool IsStringASCII(StringPiece16 str);
 #if defined(WCHAR_T_IS_UTF32)
diff --git a/src/3rdparty/chromium/base/strings/string_util_unittest.cc b/src/3rdparty/chromium/base/strings/string_util_unittest.cc
index 58eda91f0a1..f1132b9be4e 100644
--- a/src/3rdparty/chromium/base/strings/string_util_unittest.cc
+++ b/src/3rdparty/chromium/base/strings/string_util_unittest.cc
@@ -69,6 +69,128 @@ bool Truncated(const std::string& input,
     return prev != output->length();
 }
 
+using TestFunction = bool (*)(StringPiece str);
+
+// Helper used to test IsStringUTF8{,AllowingNoncharacters}.
+void TestStructurallyValidUtf8(TestFunction fn) {
+  EXPECT_TRUE(fn("abc"));
+  EXPECT_TRUE(fn("\xC2\x81"));
+  EXPECT_TRUE(fn("\xE1\x80\xBF"));
+  EXPECT_TRUE(fn("\xF1\x80\xA0\xBF"));
+  EXPECT_TRUE(fn("\xF1\x80\xA0\xBF"));
+  EXPECT_TRUE(fn("a\xC2\x81\xE1\x80\xBF\xF1\x80\xA0\xBF"));
+
+  // U+FEFF used as UTF-8 BOM.
+  // clang-format off
+  EXPECT_TRUE(fn("\xEF\xBB\xBF" "abc"));
+  // clang-format on
+
+  // Embedded nulls in canonical UTF-8 representation.
+  using std::string_literals::operator""s;
+  const std::string kEmbeddedNull = "embedded\0null"s;
+  EXPECT_TRUE(fn(kEmbeddedNull));
+}
+
+// Helper used to test IsStringUTF8{,AllowingNoncharacters}.
+void TestStructurallyInvalidUtf8(TestFunction fn) {
+  // Invalid encoding of U+1FFFE (0x8F instead of 0x9F)
+  EXPECT_FALSE(fn("\xF0\x8F\xBF\xBE"));
+
+  // Surrogate code points
+  EXPECT_FALSE(fn("\xED\xA0\x80\xED\xBF\xBF"));
+  EXPECT_FALSE(fn("\xED\xA0\x8F"));
+  EXPECT_FALSE(fn("\xED\xBF\xBF"));
+
+  // Overlong sequences
+  EXPECT_FALSE(fn("\xC0\x80"));                  // U+0000
+  EXPECT_FALSE(fn("\xC1\x80\xC1\x81"));          // "AB"
+  EXPECT_FALSE(fn("\xE0\x80\x80"));              // U+0000
+  EXPECT_FALSE(fn("\xE0\x82\x80"));              // U+0080
+  EXPECT_FALSE(fn("\xE0\x9F\xBF"));              // U+07FF
+  EXPECT_FALSE(fn("\xF0\x80\x80\x8D"));          // U+000D
+  EXPECT_FALSE(fn("\xF0\x80\x82\x91"));          // U+0091
+  EXPECT_FALSE(fn("\xF0\x80\xA0\x80"));          // U+0800
+  EXPECT_FALSE(fn("\xF0\x8F\xBB\xBF"));          // U+FEFF (BOM)
+  EXPECT_FALSE(fn("\xF8\x80\x80\x80\xBF"));      // U+003F
+  EXPECT_FALSE(fn("\xFC\x80\x80\x80\xA0\xA5"));  // U+00A5
+
+  // Beyond U+10FFFF (the upper limit of Unicode codespace)
+  EXPECT_FALSE(fn("\xF4\x90\x80\x80"));          // U+110000
+  EXPECT_FALSE(fn("\xF8\xA0\xBF\x80\xBF"));      // 5 bytes
+  EXPECT_FALSE(fn("\xFC\x9C\xBF\x80\xBF\x80"));  // 6 bytes
+
+  // BOM in UTF-16(BE|LE)
+  EXPECT_FALSE(fn("\xFE\xFF"));
+  EXPECT_FALSE(fn("\xFF\xFE"));
+
+  // Strings in legacy encodings. We can certainly make up strings
+  // in a legacy encoding that are valid in UTF-8, but in real data,
+  // most of them are invalid as UTF-8.
+
+  // cafe with U+00E9 in ISO-8859-1
+  EXPECT_FALSE(fn("caf\xE9"));
+  // U+AC00, U+AC001 in EUC-KR
+  EXPECT_FALSE(fn("\xB0\xA1\xB0\xA2"));
+  // U+4F60 U+597D in Big5
+  EXPECT_FALSE(fn("\xA7\x41\xA6\x6E"));
+  // "abc" with U+201[CD] in windows-125[0-8]
+  // clang-format off
+  EXPECT_FALSE(fn("\x93" "abc\x94"));
+  // clang-format on
+  // U+0639 U+064E U+0644 U+064E in ISO-8859-6
+  EXPECT_FALSE(fn("\xD9\xEE\xE4\xEE"));
+  // U+03B3 U+03B5 U+03B9 U+03AC in ISO-8859-7
+  EXPECT_FALSE(fn("\xE3\xE5\xE9\xDC"));
+
+  // BOM in UTF-32(BE|LE)
+  using std::string_literals::operator""s;
+  const std::string kUtf32BeBom = "\x00\x00\xFE\xFF"s;
+  EXPECT_FALSE(fn(kUtf32BeBom));
+  const std::string kUtf32LeBom = "\xFF\xFE\x00\x00"s;
+  EXPECT_FALSE(fn(kUtf32LeBom));
+}
+
+// Helper used to test IsStringUTF8{,AllowingNoncharacters}.
+void TestNoncharacters(TestFunction fn, bool expected_result) {
+  EXPECT_EQ(fn("\xEF\xB7\x90"), expected_result);      // U+FDD0
+  EXPECT_EQ(fn("\xEF\xB7\x9F"), expected_result);      // U+FDDF
+  EXPECT_EQ(fn("\xEF\xB7\xAF"), expected_result);      // U+FDEF
+  EXPECT_EQ(fn("\xEF\xBF\xBE"), expected_result);      // U+FFFE
+  EXPECT_EQ(fn("\xEF\xBF\xBF"), expected_result);      // U+FFFF
+  EXPECT_EQ(fn("\xF0\x9F\xBF\xBE"), expected_result);  // U+01FFFE
+  EXPECT_EQ(fn("\xF0\x9F\xBF\xBF"), expected_result);  // U+01FFFF
+  EXPECT_EQ(fn("\xF0\xAF\xBF\xBE"), expected_result);  // U+02FFFE
+  EXPECT_EQ(fn("\xF0\xAF\xBF\xBF"), expected_result);  // U+02FFFF
+  EXPECT_EQ(fn("\xF0\xBF\xBF\xBE"), expected_result);  // U+03FFFE
+  EXPECT_EQ(fn("\xF0\xBF\xBF\xBF"), expected_result);  // U+03FFFF
+  EXPECT_EQ(fn("\xF1\x8F\xBF\xBE"), expected_result);  // U+04FFFE
+  EXPECT_EQ(fn("\xF1\x8F\xBF\xBF"), expected_result);  // U+04FFFF
+  EXPECT_EQ(fn("\xF1\x9F\xBF\xBE"), expected_result);  // U+05FFFE
+  EXPECT_EQ(fn("\xF1\x9F\xBF\xBF"), expected_result);  // U+05FFFF
+  EXPECT_EQ(fn("\xF1\xAF\xBF\xBE"), expected_result);  // U+06FFFE
+  EXPECT_EQ(fn("\xF1\xAF\xBF\xBF"), expected_result);  // U+06FFFF
+  EXPECT_EQ(fn("\xF1\xBF\xBF\xBE"), expected_result);  // U+07FFFE
+  EXPECT_EQ(fn("\xF1\xBF\xBF\xBF"), expected_result);  // U+07FFFF
+  EXPECT_EQ(fn("\xF2\x8F\xBF\xBE"), expected_result);  // U+08FFFE
+  EXPECT_EQ(fn("\xF2\x8F\xBF\xBF"), expected_result);  // U+08FFFF
+  EXPECT_EQ(fn("\xF2\x9F\xBF\xBE"), expected_result);  // U+09FFFE
+  EXPECT_EQ(fn("\xF2\x9F\xBF\xBF"), expected_result);  // U+09FFFF
+  EXPECT_EQ(fn("\xF2\xAF\xBF\xBE"), expected_result);  // U+0AFFFE
+  EXPECT_EQ(fn("\xF2\xAF\xBF\xBF"), expected_result);  // U+0AFFFF
+  EXPECT_EQ(fn("\xF2\xBF\xBF\xBE"), expected_result);  // U+0BFFFE
+  EXPECT_EQ(fn("\xF2\xBF\xBF\xBF"), expected_result);  // U+0BFFFF
+  EXPECT_EQ(fn("\xF3\x8F\xBF\xBE"), expected_result);  // U+0CFFFE
+  EXPECT_EQ(fn("\xF3\x8F\xBF\xBF"), expected_result);  // U+0CFFFF
+  EXPECT_EQ(fn("\xF3\x9F\xBF\xBE"), expected_result);  // U+0DFFFE
+  EXPECT_EQ(fn("\xF3\x9F\xBF\xBF"), expected_result);  // U+0DFFFF
+  EXPECT_EQ(fn("\xF3\xAF\xBF\xBE"), expected_result);  // U+0EFFFE
+  EXPECT_EQ(fn("\xF3\xAF\xBF\xBF"), expected_result);  // U+0EFFFF
+  EXPECT_EQ(fn("\xF3\xBF\xBF\xBE"), expected_result);  // U+0FFFFE
+  EXPECT_EQ(fn("\xF3\xBF\xBF\xBF"), expected_result);  // U+0FFFFF
+  EXPECT_EQ(fn("\xF4\x8F\xBF\xBE"), expected_result);  // U+10FFFE
+  EXPECT_EQ(fn("\xF4\x8F\xBF\xBF"), expected_result);  // U+10FFFF
+}
+
 }  // namespace
 
 TEST(StringUtilTest, TruncateUTF8ToByteSize) {
@@ -380,69 +502,19 @@ TEST(StringUtilTest, CollapseWhitespaceASCII) {
 }
 
 TEST(StringUtilTest, IsStringUTF8) {
-  EXPECT_TRUE(IsStringUTF8("abc"));
-  EXPECT_TRUE(IsStringUTF8("\xc2\x81"));
-  EXPECT_TRUE(IsStringUTF8("\xe1\x80\xbf"));
-  EXPECT_TRUE(IsStringUTF8("\xf1\x80\xa0\xbf"));
-  EXPECT_TRUE(IsStringUTF8("a\xc2\x81\xe1\x80\xbf\xf1\x80\xa0\xbf"));
-  EXPECT_TRUE(IsStringUTF8("\xef\xbb\xbf" "abc"));  // UTF-8 BOM
-
-  // surrogate code points
-  EXPECT_FALSE(IsStringUTF8("\xed\xa0\x80\xed\xbf\xbf"));
-  EXPECT_FALSE(IsStringUTF8("\xed\xa0\x8f"));
-  EXPECT_FALSE(IsStringUTF8("\xed\xbf\xbf"));
-
-  // overlong sequences
-  EXPECT_FALSE(IsStringUTF8("\xc0\x80"));  // U+0000
-  EXPECT_FALSE(IsStringUTF8("\xc1\x80\xc1\x81"));  // "AB"
-  EXPECT_FALSE(IsStringUTF8("\xe0\x80\x80"));  // U+0000
-  EXPECT_FALSE(IsStringUTF8("\xe0\x82\x80"));  // U+0080
-  EXPECT_FALSE(IsStringUTF8("\xe0\x9f\xbf"));  // U+07ff
-  EXPECT_FALSE(IsStringUTF8("\xf0\x80\x80\x8D"));  // U+000D
-  EXPECT_FALSE(IsStringUTF8("\xf0\x80\x82\x91"));  // U+0091
-  EXPECT_FALSE(IsStringUTF8("\xf0\x80\xa0\x80"));  // U+0800
-  EXPECT_FALSE(IsStringUTF8("\xf0\x8f\xbb\xbf"));  // U+FEFF (BOM)
-  EXPECT_FALSE(IsStringUTF8("\xf8\x80\x80\x80\xbf"));  // U+003F
-  EXPECT_FALSE(IsStringUTF8("\xfc\x80\x80\x80\xa0\xa5"));  // U+00A5
-
-  // Beyond U+10FFFF (the upper limit of Unicode codespace)
-  EXPECT_FALSE(IsStringUTF8("\xf4\x90\x80\x80"));  // U+110000
-  EXPECT_FALSE(IsStringUTF8("\xf8\xa0\xbf\x80\xbf"));  // 5 bytes
-  EXPECT_FALSE(IsStringUTF8("\xfc\x9c\xbf\x80\xbf\x80"));  // 6 bytes
-
-  // BOMs in UTF-16(BE|LE) and UTF-32(BE|LE)
-  EXPECT_FALSE(IsStringUTF8("\xfe\xff"));
-  EXPECT_FALSE(IsStringUTF8("\xff\xfe"));
-  EXPECT_FALSE(IsStringUTF8(std::string("\x00\x00\xfe\xff", 4)));
-  EXPECT_FALSE(IsStringUTF8("\xff\xfe\x00\x00"));
+  {
+    SCOPED_TRACE("IsStringUTF8");
+    TestStructurallyValidUtf8(&IsStringUTF8);
+    TestStructurallyInvalidUtf8(&IsStringUTF8);
+    TestNoncharacters(&IsStringUTF8, false);
+  }
 
-  // Non-characters : U+xxFFF[EF] where xx is 0x00 through 0x10 and <FDD0,FDEF>
-  EXPECT_FALSE(IsStringUTF8("\xef\xbf\xbe"));  // U+FFFE)
-  EXPECT_FALSE(IsStringUTF8("\xf0\x8f\xbf\xbe"));  // U+1FFFE
-  EXPECT_FALSE(IsStringUTF8("\xf3\xbf\xbf\xbf"));  // U+10FFFF
-  EXPECT_FALSE(IsStringUTF8("\xef\xb7\x90"));  // U+FDD0
-  EXPECT_FALSE(IsStringUTF8("\xef\xb7\xaf"));  // U+FDEF
-  // Strings in legacy encodings. We can certainly make up strings
-  // in a legacy encoding that are valid in UTF-8, but in real data,
-  // most of them are invalid as UTF-8.
-  EXPECT_FALSE(IsStringUTF8("caf\xe9"));  // cafe with U+00E9 in ISO-8859-1
-  EXPECT_FALSE(IsStringUTF8("\xb0\xa1\xb0\xa2"));  // U+AC00, U+AC001 in EUC-KR
-  EXPECT_FALSE(IsStringUTF8("\xa7\x41\xa6\x6e"));  // U+4F60 U+597D in Big5
-  // "abc" with U+201[CD] in windows-125[0-8]
-  EXPECT_FALSE(IsStringUTF8("\x93" "abc\x94"));
-  // U+0639 U+064E U+0644 U+064E in ISO-8859-6
-  EXPECT_FALSE(IsStringUTF8("\xd9\xee\xe4\xee"));
-  // U+03B3 U+03B5 U+03B9 U+03AC in ISO-8859-7
-  EXPECT_FALSE(IsStringUTF8("\xe3\xe5\xe9\xdC"));
-
-  // Check that we support Embedded Nulls. The first uses the canonical UTF-8
-  // representation, and the second uses a 2-byte sequence. The second version
-  // is invalid UTF-8 since UTF-8 states that the shortest encoding for a
-  // given codepoint must be used.
-  static const char kEmbeddedNull[] = "embedded\0null";
-  EXPECT_TRUE(IsStringUTF8(
-      std::string(kEmbeddedNull, sizeof(kEmbeddedNull))));
-  EXPECT_FALSE(IsStringUTF8("embedded\xc0\x80U+0000"));
+  {
+    SCOPED_TRACE("IsStringUTF8AllowingNoncharacters");
+    TestStructurallyValidUtf8(&IsStringUTF8AllowingNoncharacters);
+    TestStructurallyInvalidUtf8(&IsStringUTF8AllowingNoncharacters);
+    TestNoncharacters(&IsStringUTF8AllowingNoncharacters, true);
+  }
 }
 
 TEST(StringUtilTest, IsStringASCII) {
diff --git a/src/3rdparty/chromium/base/strings/utf_string_conversion_utils.h b/src/3rdparty/chromium/base/strings/utf_string_conversion_utils.h
index 2d95870c580..01d24c3e2e6 100644
--- a/src/3rdparty/chromium/base/strings/utf_string_conversion_utils.h
+++ b/src/3rdparty/chromium/base/strings/utf_string_conversion_utils.h
@@ -17,16 +17,19 @@
 namespace base {
 
 inline bool IsValidCodepoint(uint32_t code_point) {
-  // Excludes the surrogate code points ([0xD800, 0xDFFF]) and
-  // codepoints larger than 0x10FFFF (the highest codepoint allowed).
-  // Non-characters and unassigned codepoints are allowed.
+  // Excludes code points that are not Unicode scalar values, i.e.
+  // surrogate code points ([0xD800, 0xDFFF]). Additionally, excludes
+  // code points larger than 0x10FFFF (the highest codepoint allowed).
+  // Non-characters and unassigned code points are allowed.
+  // https://unicode.org/glossary/#unicode_scalar_value
   return code_point < 0xD800u ||
          (code_point >= 0xE000u && code_point <= 0x10FFFFu);
 }
 
 inline bool IsValidCharacter(uint32_t code_point) {
-  // Excludes non-characters (U+FDD0..U+FDEF, and all codepoints ending in
-  // 0xFFFE or 0xFFFF) from the set of valid code points.
+  // Excludes non-characters (U+FDD0..U+FDEF, and all code points
+  // ending in 0xFFFE or 0xFFFF) from the set of valid code points.
+  // https://unicode.org/faq/private_use.html#nonchar1
   return code_point < 0xD800u || (code_point >= 0xE000u &&
       code_point < 0xFDD0u) || (code_point > 0xFDEFu &&
       code_point <= 0x10FFFFu && (code_point & 0xFFFEu) != 0xFFFEu);
diff --git a/src/3rdparty/chromium/base/values.cc b/src/3rdparty/chromium/base/values.cc
index ebc8689293f..e339b25a84a 100644
--- a/src/3rdparty/chromium/base/values.cc
+++ b/src/3rdparty/chromium/base/values.cc
@@ -221,7 +221,7 @@ Value::Value(StringPiece in_string) : Value(std::string(in_string)) {}
 
 Value::Value(std::string&& in_string) noexcept
     : type_(Type::STRING), string_value_(std::move(in_string)) {
-  DCHECK(IsStringUTF8(string_value_));
+  DCHECK(IsStringUTF8AllowingNoncharacters(string_value_));
 }
 
 Value::Value(const char16* in_string16) : Value(StringPiece16(in_string16)) {}
@@ -1214,7 +1214,7 @@ DictionaryValue::DictionaryValue(DictStorage&& in_dict) noexcept
     : Value(std::move(in_dict)) {}
 
 bool DictionaryValue::HasKey(StringPiece key) const {
-  DCHECK(IsStringUTF8(key));
+  DCHECK(IsStringUTF8AllowingNoncharacters(key));
   auto current_entry = dict_.find(key);
   DCHECK((current_entry == dict_.end()) || current_entry->second);
   return current_entry != dict_.end();
@@ -1225,7 +1225,7 @@ void DictionaryValue::Clear() {
 }
 
 Value* DictionaryValue::Set(StringPiece path, std::unique_ptr<Value> in_value) {
-  DCHECK(IsStringUTF8(path));
+  DCHECK(IsStringUTF8AllowingNoncharacters(path));
   DCHECK(in_value);
 
   // IMPORTANT NOTE: Do not replace with SetPathInternal() yet, because the
@@ -1300,7 +1300,7 @@ Value* DictionaryValue::SetWithoutPathExpansion(
 
 bool DictionaryValue::Get(StringPiece path,
                           const Value** out_value) const {
-  DCHECK(IsStringUTF8(path));
+  DCHECK(IsStringUTF8AllowingNoncharacters(path));
   const Value* value = FindPath(path);
   if (!value)
     return false;
@@ -1425,7 +1425,7 @@ bool DictionaryValue::GetList(StringPiece path, ListValue** out_value) {
 
 bool DictionaryValue::GetWithoutPathExpansion(StringPiece key,
                                               const Value** out_value) const {
-  DCHECK(IsStringUTF8(key));
+  DCHECK(IsStringUTF8AllowingNoncharacters(key));
   auto entry_iterator = dict_.find(key);
   if (entry_iterator == dict_.end())
     return false;
@@ -1530,7 +1530,7 @@ bool DictionaryValue::GetListWithoutPathExpansion(StringPiece key,
 
 bool DictionaryValue::Remove(StringPiece path,
                              std::unique_ptr<Value>* out_value) {
-  DCHECK(IsStringUTF8(path));
+  DCHECK(IsStringUTF8AllowingNoncharacters(path));
   StringPiece current_path(path);
   DictionaryValue* current_dictionary = this;
   size_t delimiter_position = current_path.rfind('.');
@@ -1548,7 +1548,7 @@ bool DictionaryValue::Remove(StringPiece path,
 bool DictionaryValue::RemoveWithoutPathExpansion(
     StringPiece key,
     std::unique_ptr<Value>* out_value) {
-  DCHECK(IsStringUTF8(key));
+  DCHECK(IsStringUTF8AllowingNoncharacters(key));
   auto entry_iterator = dict_.find(key);
   if (entry_iterator == dict_.end())
     return false;
diff --git a/src/3rdparty/chromium/services/data_decoder/public/cpp/android/java/src/org/chromium/services/data_decoder/JsonSanitizer.java b/src/3rdparty/chromium/services/data_decoder/public/cpp/android/java/src/org/chromium/services/data_decoder/JsonSanitizer.java
index f398f4115d3..868cb60c850 100644
--- a/src/3rdparty/chromium/services/data_decoder/public/cpp/android/java/src/org/chromium/services/data_decoder/JsonSanitizer.java
+++ b/src/3rdparty/chromium/services/data_decoder/public/cpp/android/java/src/org/chromium/services/data_decoder/JsonSanitizer.java
@@ -148,7 +148,7 @@ public class JsonSanitizer {
 
     /**
      * Checks whether a given String is well-formed UTF-16, i.e. all surrogates appear in high-low
-     * pairs and each code point is a valid character.
+     * pairs, in other words: each character is a valid Unicode code point.
      *
      * @param string The string to check.
      * @return Whether the given string is well-formed UTF-16.
@@ -159,7 +159,7 @@ public class JsonSanitizer {
             char c = string.charAt(i);
             // Check that surrogates only appear in pairs of a high surrogate followed by a low
             // surrogate.
-            // A lone low surrogate is not allowed.
+            // A lone surrogate is not allowed.
             if (Character.isLowSurrogate(c)) return false;
 
             int codePoint;
@@ -174,22 +174,14 @@ public class JsonSanitizer {
                 // Decode the high-low pair into a code point.
                 codePoint = Character.toCodePoint(high, low);
             } else {
-                // The code point is neither a low surrogate nor a high surrogate, so we just need
-                // to check that it's a valid character.
+                // The code point is neither a low surrogate nor a high surrogate, so
+                // it's a valid Unicode character.
                 codePoint = c;
             }
-
-            if (!isUnicodeCharacter(codePoint)) return false;
         }
         return true;
     }
 
-    private static boolean isUnicodeCharacter(int codePoint) {
-        // See the native method base::IsValidCharacter().
-        return codePoint < 0xD800 || (codePoint >= 0xE000 && codePoint < 0xFDD0)
-                || (codePoint > 0xFDEF && codePoint <= 0x10FFFF && (codePoint & 0xFFFE) != 0xFFFE);
-    }
-
     @NativeMethods
     interface Natives {
         void onSuccess(long id, String json);
diff --git a/src/3rdparty/chromium/services/data_decoder/public/cpp/json_sanitizer_android.cc b/src/3rdparty/chromium/services/data_decoder/public/cpp/json_sanitizer_android.cc
index 5ed2b7aed63..b4e7efb1ba5 100644
--- a/src/3rdparty/chromium/services/data_decoder/public/cpp/json_sanitizer_android.cc
+++ b/src/3rdparty/chromium/services/data_decoder/public/cpp/json_sanitizer_android.cc
@@ -35,7 +35,7 @@ namespace data_decoder {
 // static
 void JsonSanitizer::Sanitize(const std::string& json, Callback callback) {
   // The JSON parser only accepts wellformed UTF-8.
-  if (!base::IsStringUTF8(json)) {
+  if (!base::IsStringUTF8AllowingNoncharacters(json)) {
     base::SequencedTaskRunnerHandle::Get()->PostTask(
         FROM_HERE, base::BindOnce(std::move(callback),
                                   Result::Error("Unsupported encoding")));
diff --git a/src/3rdparty/chromium/services/data_decoder/public/cpp/json_sanitizer_unittest.cc b/src/3rdparty/chromium/services/data_decoder/public/cpp/json_sanitizer_unittest.cc
index b3d53dc38de..cbc0d7da423 100644
--- a/src/3rdparty/chromium/services/data_decoder/public/cpp/json_sanitizer_unittest.cc
+++ b/src/3rdparty/chromium/services/data_decoder/public/cpp/json_sanitizer_unittest.cc
@@ -46,7 +46,7 @@ void CheckSuccess(const std::string& json) {
   EXPECT_TRUE(result_received);
 }
 
-// Verifies that |json| is rejected by the sanitizer as an invlid string.
+// Verifies that |json| is rejected by the sanitizer as an invalid string.
 void CheckError(const std::string& json) {
   base::RunLoop loop;
   bool result_received = false;
@@ -135,10 +135,44 @@ TEST_F(DataDecoderJsonSanitizerTest, Unicode) {
   // A low surrogate followed by a high surrogate.
   CheckError("[\"\\ude03\\ud83d\"]");
 
-  // Valid escaped UTF-16 that encodes non-characters:
-  CheckError("[\"\\ufdd0\"]");
-  CheckError("[\"\\ufffe\"]");
-  CheckError("[\"\\ud83f\\udffe\"]");
+  // Valid escaped UTF-16 that encodes non-characters.
+  CheckSuccess("[\"\\uFDD0\"]");         // U+FDD0
+  CheckSuccess("[\"\\uFDDF\"]");         // U+FDDF
+  CheckSuccess("[\"\\uFDEF\"]");         // U+FDEF
+  CheckSuccess("[\"\\uFFFE\"]");         // U+FFFE
+  CheckSuccess("[\"\\uFFFF\"]");         // U+FFFF
+  CheckSuccess("[\"\\uD83F\\uDFFE\"]");  // U+01FFFE
+  CheckSuccess("[\"\\uD83F\\uDFFF\"]");  // U+01FFFF
+  CheckSuccess("[\"\\uD87F\\uDFFE\"]");  // U+02FFFE
+  CheckSuccess("[\"\\uD87F\\uDFFF\"]");  // U+02FFFF
+  CheckSuccess("[\"\\uD8BF\\uDFFE\"]");  // U+03FFFE
+  CheckSuccess("[\"\\uD8BF\\uDFFF\"]");  // U+03FFFF
+  CheckSuccess("[\"\\uD8FF\\uDFFE\"]");  // U+04FFFE
+  CheckSuccess("[\"\\uD8FF\\uDFFF\"]");  // U+04FFFF
+  CheckSuccess("[\"\\uD93F\\uDFFE\"]");  // U+05FFFE
+  CheckSuccess("[\"\\uD93F\\uDFFF\"]");  // U+05FFFF
+  CheckSuccess("[\"\\uD97F\\uDFFE\"]");  // U+06FFFE
+  CheckSuccess("[\"\\uD97F\\uDFFF\"]");  // U+06FFFF
+  CheckSuccess("[\"\\uD9BF\\uDFFE\"]");  // U+07FFFE
+  CheckSuccess("[\"\\uD9BF\\uDFFF\"]");  // U+07FFFF
+  CheckSuccess("[\"\\uD9FF\\uDFFE\"]");  // U+08FFFE
+  CheckSuccess("[\"\\uD9FF\\uDFFF\"]");  // U+08FFFF
+  CheckSuccess("[\"\\uDA3F\\uDFFE\"]");  // U+09FFFE
+  CheckSuccess("[\"\\uDA3F\\uDFFF\"]");  // U+09FFFF
+  CheckSuccess("[\"\\uDA7F\\uDFFE\"]");  // U+0AFFFE
+  CheckSuccess("[\"\\uDA7F\\uDFFF\"]");  // U+0AFFFF
+  CheckSuccess("[\"\\uDABF\\uDFFE\"]");  // U+0BFFFE
+  CheckSuccess("[\"\\uDABF\\uDFFF\"]");  // U+0BFFFF
+  CheckSuccess("[\"\\uDAFF\\uDFFE\"]");  // U+0CFFFE
+  CheckSuccess("[\"\\uDAFF\\uDFFF\"]");  // U+0CFFFF
+  CheckSuccess("[\"\\uDB3F\\uDFFE\"]");  // U+0DFFFE
+  CheckSuccess("[\"\\uDB3F\\uDFFF\"]");  // U+0DFFFF
+  CheckSuccess("[\"\\uDB7F\\uDFFE\"]");  // U+0EFFFE
+  CheckSuccess("[\"\\uDB7F\\uDFFF\"]");  // U+0EFFFF
+  CheckSuccess("[\"\\uDBBF\\uDFFE\"]");  // U+0FFFFE
+  CheckSuccess("[\"\\uDBBF\\uDFFF\"]");  // U+0FFFFF
+  CheckSuccess("[\"\\uDBFF\\uDFFE\"]");  // U+10FFFE
+  CheckSuccess("[\"\\uDBFF\\uDFFF\"]");  // U+10FFFF
 }
 
 }  // namespace
